<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[testpost]]></title>
    <url>%2Fnotesblog%2F2017%2F09%2F18%2Ftestpost%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java多线程-基础篇]]></title>
    <url>%2Fnotesblog%2F2017%2F09%2F18%2Fthread%2F</url>
    <content type="text"><![CDATA[在J2EE开发中很多地方都会用到线程，这样不仅可以提高执行效率，而且还可以提高资源的利用率 线程基础线程的状态： NEW 线程刚创建，尚未启动 RUNNABLE 线程正在运行中，在这种状态下不会发生wait、sleep的等待状态 BLOCKED 在多个线程有同步操作的场景 WAITING 线程拥有了某个锁之后，调用了他的wait方法 TIMEDWAITING 有时间限制的WAITING _ TERMINATED 线程已经运行完，基本等于死了 NEW状态：直接创建一个线程然后获取状态 123456public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread t = new Thread(); System.out.println(t.getState()); &#125;&#125; 执行结果：NEW RUNNABLE 状态：线程执行后获取状态 123456789101112131415public class RunnableThread &#123; public static void main(String[] args) &#123; Thread t = new Thread() &#123; @Override public void run() &#123; for(int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123; System.out.println(i); &#125; &#125; &#125;; t.start(); System.out.println(t.getState()); &#125;&#125; 执行结果：RUNNABLE BLOCKED状态：多个线程相互等待synchronized时，线程会出现BLOCKED状态； 1234567891011121314151617181920212223public class BlockedThread &#123; public static void main(String[] args) &#123; final Object lock = new Object(); Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; Integer.MIN_VALUE; i++) &#123; synchronized (lock) &#123; System.out.println(i); &#125; &#125; &#125; &#125;; Thread t1 = new Thread(r); t1.setName("t1"); Thread t2 = new Thread(r); t2.setName("t2"); t1.start(); t2.start(); &#125;&#125; 这个时候一个线程RUNNABLE，另一个就是BLOCKED ######WAITING 状态： 这个需要用到生产者消费者模型, 当生产者生产过慢的时候, 消费者就会等待生产者的下一次notify; 1234567891011121314151617181920212223242526272829303132333435363738public class WaitingThread &#123; public static void main(String[] args) &#123; final Object lock = new Object(); Thread t1 = new Thread() &#123; @Override public void run() &#123; int i = 0; while(true) &#123; synchronized (lock) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(i++); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; while(true) &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; System.out.println(i); &#125; lock.notifyAll(); &#125; &#125; &#125;; t1.setName("t1"); t2.setName("t2"); t1.start(); t2.start(); &#125;&#125; TIMED_WAITING：在上个例子的基础上wait加上时间参数就OK了； 12345678synchronized (lock) &#123; try &#123; lock.wait(60*1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(i++);&#125; t1现在为TIMED_WAITING (on object monitor)这里括号里还可能是sleeping等其它情况。 TERMINATED ：线程运行结束就是TERMINATED状态 12345678910private static void TERMINATED() &#123; Thread t1 = new Thread(); t1.start(); System. out.println(t1.getState()); try &#123; Thread. sleep(1000L); &#125; catch (InterruptedException e) &#123; &#125; System. out.println(t1.getState());&#125; 执行结果： ​ RUNNABLE ​ TERMINATED]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fnotesblog%2F2017%2F09%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器Typora]]></title>
    <url>%2Fnotesblog%2F2017%2F09%2F15%2FTypora%2F</url>
    <content type="text"><![CDATA[关于Typora 无意中找到Typora 这个编辑器，用过之后不想在换了；这是一个功能强大的Markdown编辑器，输入即输出，还可以导出PDF文件和HTLM文件。 [TOC] 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生Underline的效果 代码 使用`包裹的内容将会已代码的形式展现： 例如：function() 输入123456789例如：~~~javapublic class DemoClass&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 强调使用两个*或两个_包裹 例如： 12**强调内容**__强调内容__ 输出 ​ 强调内容 ​ 强调内容 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 插入图片我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 插入URL连接使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接: http://www.baidu.com/ 目录列表Table of Contents（TOC）输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线使用***或者---，然后回车，来产生水平分割线。 标注我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 表格12345|姓名|性别|公司|薪资||:---|:---:|:---:|---:||马云|男|阿里巴巴|3200||马化腾|男|腾讯|5000||坑货|女|呵呵哒|2000| 效果： 姓名 性别 公司 薪资 马云 男 阿里巴巴 3200 马化腾 男 腾讯 5000 坑货 女 呵呵哒 2000 任务列表1234- [ ] 写代码- [ ] 写代码- [ ] 写代码- [ ] 写代码 写代码 写代码 写代码 写代码 列表输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序列表*** XXXXXX* XXXXXX* XXXXXXX 无序列表 XXXXXX XXXXXX XXXXXXX 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 这是一个块引用！ 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。 下载地址]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>editer</tag>
      </tags>
  </entry>
</search>
